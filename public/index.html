<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Live Voice Call with AI</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 900px;
    margin: 0 auto;
    background: white;
    border-radius: 15px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.1);
    overflow: hidden;
}

h1 {
    background: linear-gradient(45deg, #667eea, #764ba2);
    color: white;
    text-align: center;
    padding: 20px;
    margin: 0;
    font-size: 1.8rem;
}

.call-status {
    text-align: center;
    padding: 20px;
    font-weight: bold;
    font-size: 1.2rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.3s ease;
}

.call-status.disconnected {
    background: #f44336;
    color: white;
}

.call-status.connecting {
    background: #ff9800;
    color: white;
}

.call-status.connected {
    background: #4CAF50;
    color: white;
}

.call-status.listening {
    background: #2196F3;
    color: white;
    animation: pulse 1.5s infinite;
}

.call-status.processing {
    background: #9C27B0;
    color: white;
    animation: pulse 1s infinite;
}

.call-status.speaking {
    background: #FF5722;
    color: white;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.8; transform: scale(1.02); }
    100% { opacity: 1; transform: scale(1); }
}

.call-controls {
    display: flex;
    justify-content: center;
    gap: 20px;
    padding: 20px;
    background: #f5f5f5;
}

.btn {
    padding: 15px 30px;
    border: none;
    border-radius: 50px;
    font-size: 1.1rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
    min-width: 140px;
}

.btn:hover:not(:disabled) {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.2);
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

#startCallBtn {
    background: #4CAF50;
    color: white;
}

#endCallBtn {
    background: #f44336;
    color: white;
}

.audio-indicators {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    padding: 20px;
    background: #f9f9f9;
}

.indicator-section {
    background: white;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.indicator-section h3 {
    margin-bottom: 15px;
    color: #333;
    font-size: 1.1rem;
    text-align: center;
}

.volume-indicator {
    height: 100px;
    background: #f0f0f0;
    border-radius: 10px;
    position: relative;
    overflow: hidden;
    border: 2px solid #ddd;
}

.volume-bar {
    width: 100%;
    background: linear-gradient(to top, #4CAF50, #8BC34A, #CDDC39, #FFEB3B, #FF9800, #FF5722);
    border-radius: 8px;
    transition: height 0.1s ease;
    position: absolute;
    bottom: 0;
}

.speech-indicator {
    text-align: center;
    padding: 15px;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1rem;
    min-height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.speech-indicator.idle {
    background: #e0e0e0;
    color: #666;
}

.speech-indicator.listening {
    background: #e3f2fd;
    color: #1976d2;
}

.speech-indicator.speaking {
    background: #fff3e0;
    color: #f57c00;
}

.speech-indicator.processing {
    background: #f3e5f5;
    color: #7b1fa2;
}

.live-transcript {
    padding: 20px;
    border-top: 1px solid #ddd;
}

.live-transcript h2 {
    color: #333;
    margin-bottom: 15px;
    font-size: 1.3rem;
    text-align: center;
}

.transcript-container {
    background: #fafafa;
    border-radius: 10px;
    padding: 20px;
    min-height: 200px;
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid #ddd;
}

.transcript-line {
    margin: 15px 0;
    padding: 12px;
    border-radius: 8px;
    border-left: 4px solid;
    position: relative;
}

.transcript-line.user {
    background: #e3f2fd;
    border-left-color: #2196F3;
}

.transcript-line.ai {
    background: #f3e5f5;
    border-left-color: #9c27b0;
}

.transcript-line.interim {
    background: #fff3e0;
    border-left-color: #ff9800;
    font-style: italic;
    opacity: 0.8;
}

.transcript-line.system {
    background: #e8f5e8;
    border-left-color: #4caf50;
    font-size: 0.9rem;
}

.transcript-text {
    font-size: 1rem;
    line-height: 1.4;
    margin-bottom: 5px;
}

.transcript-meta {
    font-size: 0.8rem;
    color: #666;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.confidence-badge {
    background: #4caf50;
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.7rem;
    font-weight: bold;
}

.confidence-badge.low {
    background: #ff9800;
}

.confidence-badge.very-low {
    background: #f44336;
}

.performance-stats {
    padding: 20px;
    background: #e8f5e8;
    border-top: 1px solid #ddd;
}

.performance-stats h3 {
    color: #2e7d32;
    margin-bottom: 15px;
    font-size: 1.2rem;
    text-align: center;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
}

.stat-card {
    background: white;
    padding: 15px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    border: 1px solid #c8e6c9;
}

.stat-label {
    font-size: 0.85rem;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 5px;
}

.stat-value {
    font-size: 1.4rem;
    font-weight: bold;
    color: #2e7d32;
}

.audio-controls {
    padding: 20px;
    background: #f0f8ff;
    border-top: 1px solid #ddd;
}

.audio-controls h3 {
    color: #1565c0;
    margin-bottom: 15px;
    font-size: 1.2rem;
    text-align: center;
}

.audio-player {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
}

.audio-status {
    padding: 10px 20px;
    background: white;
    border-radius: 20px;
    border: 1px solid #ddd;
    font-size: 0.9rem;
    color: #666;
}

.audio-status.playing {
    background: #c8e6c9;
    border-color: #4caf50;
    color: #2e7d32;
}

.audio-controls-row {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
}

.audio-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 20px;
    font-size: 0.9rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

.audio-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.audio-btn.play {
    background: #4caf50;
    color: white;
}

.audio-btn.stop {
    background: #f44336;
    color: white;
}

.audio-btn.download {
    background: #2196f3;
    color: white;
}

/* Responsive design */
@media (max-width: 768px) {
    .audio-indicators {
        grid-template-columns: 1fr;
    }
    
    .call-controls {
        flex-direction: column;
        align-items: center;
    }
    
    .btn {
        width: 200px;
    }
    
    .stats-grid {
        grid-template-columns: 1fr 1fr;
    }
}

@media (max-width: 480px) {
    .stats-grid {
        grid-template-columns: 1fr;
    }
    
    .audio-controls-row {
        flex-direction: column;
        align-items: center;
    }
}
</style>
</head>
<body>
<div class="container">
<h1>Live Voice Call with AI</h1>

<div class="call-status" id="callStatus">Disconnected</div>

<div class="call-controls">
<button id="startCallBtn" class="btn">Start Call</button>
<button id="endCallBtn" class="btn" disabled>End Call</button>
</div>

<div class="audio-indicators">
<div class="indicator-section">
<h3>Your Voice Level</h3>
<div class="volume-indicator" id="inputVolumeIndicator">
<div class="volume-bar" id="inputVolumeBar"></div>
</div>
</div>

<div class="indicator-section">
<h3>Call Status</h3>
<div class="speech-indicator idle" id="speechStatus">Ready to start call</div>
</div>
</div>

<div class="live-transcript">
<h2>Live Conversation</h2>
<div class="transcript-container" id="transcriptContainer">
<div class="transcript-line system">
<div class="transcript-text">Click "Start Call" to begin your live conversation with AI</div>
<div class="transcript-meta">
<span>System</span>
<span id="currentTime"></span>
</div>
</div>
</div>
</div>

<div class="audio-controls">
<h3>AI Audio Response</h3>
<div class="audio-player">
<div class="audio-status" id="audioStatus">No audio available</div>
<audio id="responseAudio" controls style="display: none; width: 100%; max-width: 400px;"></audio>
<div class="audio-controls-row">
<button id="playBtn" class="audio-btn play" disabled>Play Last</button>
<button id="stopAudioBtn" class="audio-btn stop" disabled>Stop Audio</button>
<button id="downloadBtn" class="audio-btn download" disabled>Download</button>
</div>
</div>
</div>

<div class="performance-stats">
<h3>Performance Metrics</h3>
<div class="stats-grid">
<div class="stat-card">
<div class="stat-label">Response Time</div>
<div class="stat-value" id="lastResponseTime">--</div>
</div>
<div class="stat-card">
<div class="stat-label">Average Time</div>
<div class="stat-value" id="avgResponseTime">--</div>
</div>
<div class="stat-card">
<div class="stat-label">Call Duration</div>
<div class="stat-value" id="callDuration">--</div>
</div>
<div class="stat-card">
<div class="stat-label">Messages</div>
<div class="stat-value" id="messageCount">0</div>
</div>
</div>
</div>

</div>

<script>
class LiveVoiceCall {
    constructor() {
        this.ws = null;
        this.callSid = 'live-call-' + Math.random().toString(36).substring(2, 10);
        this.isCallActive = false;
        this.isRecording = false;
        this.mediaRecorder = null;
        this.audioContext = null;
        this.analyser = null;
        this.microphone = null;
        this.animationFrame = null;
        
        // Call state
        this.callStartTime = null;
        this.responseTimeHistory = [];
        this.messageCount = 0;
        this.lastAudioResponse = null;
        this.currentAudioUrl = null;
        this.isPlayingAudio = false;
        
        // Audio processing
        this.vadThreshold = 0.01;
        this.silenceTimeout = null;
        this.isSpeaking = false;
        this.speechStartTime = null;
        this.volumeHistory = [];
        
        // Transcript state
        this.currentInterimTranscript = '';
        this.finalTranscripts = [];
        
        this.initializeElements();
        this.setupEventListeners();
        this.updateTime();
        setInterval(() => this.updateTime(), 1000);
    }

    initializeElements() {
        this.callStatus = document.getElementById('callStatus');
        this.startCallBtn = document.getElementById('startCallBtn');
        this.endCallBtn = document.getElementById('endCallBtn');
        this.inputVolumeBar = document.getElementById('inputVolumeBar');
        this.speechStatus = document.getElementById('speechStatus');
        this.transcriptContainer = document.getElementById('transcriptContainer');
        this.responseAudio = document.getElementById('responseAudio');
        this.audioStatus = document.getElementById('audioStatus');
        this.playBtn = document.getElementById('playBtn');
        this.stopAudioBtn = document.getElementById('stopAudioBtn');
        this.downloadBtn = document.getElementById('downloadBtn');
        
        // Stats elements
        this.lastResponseTime = document.getElementById('lastResponseTime');
        this.avgResponseTime = document.getElementById('avgResponseTime');
        this.callDurationEl = document.getElementById('callDuration');
        this.messageCountEl = document.getElementById('messageCount');
    }

    setupEventListeners() {
        this.startCallBtn.addEventListener('click', () => this.startCall());
        this.endCallBtn.addEventListener('click', () => this.endCall());
        this.playBtn.addEventListener('click', () => this.playLastResponse());
        this.stopAudioBtn.addEventListener('click', () => this.stopAllAudio());
        this.downloadBtn.addEventListener('click', () => this.downloadLastResponse());

        this.responseAudio.addEventListener('play', () => {
            this.isPlayingAudio = true;
            this.audioStatus.textContent = 'Playing AI response...';
            this.audioStatus.classList.add('playing');
            this.stopAudioBtn.disabled = false;
        });

        this.responseAudio.addEventListener('pause', () => {
            this.isPlayingAudio = false;
            this.audioStatus.textContent = 'Audio paused';
            this.audioStatus.classList.remove('playing');
            this.stopAudioBtn.disabled = true;
        });

        this.responseAudio.addEventListener('ended', () => {
            this.isPlayingAudio = false;
            this.audioStatus.textContent = 'Audio ready to play';
            this.audioStatus.classList.remove('playing');
            this.stopAudioBtn.disabled = true;
        });
    }

    updateTime() {
        const now = new Date();
        document.getElementById('currentTime').textContent = now.toLocaleTimeString();
        
        if (this.callStartTime) {
            const duration = Math.floor((Date.now() - this.callStartTime) / 1000);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            this.callDurationEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
    }

    async startCall() {
        try {
            this.updateCallStatus('connecting', 'Connecting...');
            this.startCallBtn.disabled = true;
            
            // Connect to WebSocket
            await this.connectWebSocket();
            
            // Request microphone access
            await this.setupAudio();
            
            // Start the call
            this.isCallActive = true;
            this.callStartTime = Date.now();
            this.responseTimeHistory = [];
            this.messageCount = 0;
            
            this.updateCallStatus('listening', 'Listening...');
            this.endCallBtn.disabled = false;
            this.speechStatus.textContent = 'Say something to start conversation';
            this.speechStatus.className = 'speech-indicator listening';
            
            this.addSystemMessage('Call started - speak naturally, AI will respond when you pause');
            
        } catch (error) {
            console.error('Failed to start call:', error);
            this.addSystemMessage(`Failed to start call: ${error.message}`);
            this.updateCallStatus('disconnected', 'Disconnected');
            this.startCallBtn.disabled = false;
        }
    }

    async connectWebSocket() {
        return new Promise((resolve, reject) => {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}?callSid=${this.callSid}`;
            
            this.ws = new WebSocket(wsUrl);
            
            this.ws.onopen = () => {
                console.log('WebSocket connected');
                resolve();
            };
            
            this.ws.onmessage = (event) => {
                this.handleWebSocketMessage(event);
            };
            
            this.ws.onclose = () => {
                console.log('WebSocket disconnected');
                if (this.isCallActive) {
                    this.addSystemMessage('Connection lost');
                    this.endCall();
                }
            };
            
            this.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                reject(new Error('WebSocket connection failed'));
            };
            
            setTimeout(() => reject(new Error('Connection timeout')), 10000);
        });
    }

    async setupAudio() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    sampleRate: 16000
                }
            });

            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.microphone = this.audioContext.createMediaStreamSource(stream);
            this.analyser = this.audioContext.createAnalyser();
            
            this.analyser.fftSize = 256;
            this.analyser.smoothingTimeConstant = 0.8;
            this.microphone.connect(this.analyser);
            
            // Setup audio streaming
            this.setupAudioStreaming(stream);
            
            // Start volume monitoring
            this.startVolumeMonitoring();
            
        } catch (error) {
            throw new Error('Microphone access denied or unavailable');
        }
    }

    setupAudioStreaming(stream) {
        this.mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'audio/webm;codecs=opus'
        });

        this.mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0 && this.ws && this.ws.readyState === WebSocket.OPEN) {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64Audio = reader.result.split(',')[1];
                    this.ws.send(JSON.stringify({
                        type: 'audio_stream',
                        audioData: base64Audio,
                        timestamp: Date.now()
                    }));
                };
                reader.readAsDataURL(event.data);
            }
        };

        // Stream audio in small chunks
        this.mediaRecorder.start(100); // 100ms chunks
        this.isRecording = true;
    }

    startVolumeMonitoring() {
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const monitor = () => {
            if (!this.isCallActive) return;
            
            this.animationFrame = requestAnimationFrame(monitor);
            this.analyser.getByteFrequencyData(dataArray);
            
            // Calculate average volume
            const average = dataArray.reduce((a, b) => a + b) / bufferLength;
            const volume = average / 255;
            
            this.volumeHistory.push(volume);
            if (this.volumeHistory.length > 10) {
                this.volumeHistory.shift();
            }
            
            // Update volume indicator
            this.inputVolumeBar.style.height = `${Math.min(volume * 100, 100)}%`;
            
            // Voice activity detection
            this.handleVoiceActivity(volume);
        };
        
        monitor();
    }

    handleVoiceActivity(volume) {
        const isCurrentlySpeaking = volume > this.vadThreshold;
        
        if (isCurrentlySpeaking && !this.isSpeaking) {
            // Speech started
            this.isSpeaking = true;
            this.speechStartTime = Date.now();
            this.speechStatus.textContent = 'You are speaking...';
            this.speechStatus.className = 'speech-indicator speaking';
            
            if (this.silenceTimeout) {
                clearTimeout(this.silenceTimeout);
                this.silenceTimeout = null;
            }
            
            // Send speech started signal
            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({
                    type: 'speech_started',
                    timestamp: Date.now()
                }));
            }
            
        } else if (!isCurrentlySpeaking && this.isSpeaking) {
            // Potential speech end - wait for confirmation
            if (this.silenceTimeout) {
                clearTimeout(this.silenceTimeout);
            }
            
            this.silenceTimeout = setTimeout(() => {
                this.isSpeaking = false;
                this.speechStatus.textContent = 'Processing...';
                this.speechStatus.className = 'speech-indicator processing';
                
                // Send speech ended signal
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'speech_ended',
                        timestamp: Date.now()
                    }));
                }
            }, 1000); // 1 second of silence before considering speech ended
        }
    }

    handleWebSocketMessage(event) {
        try {
            const message = JSON.parse(event.data);
            
            switch (message.type) {
                case 'ready':
                    console.log('Server ready');
                    break;
                    
                case 'transcript':
                    this.handleTranscript(message);
                    break;
                    
                case 'ai_response':
                    this.handleAIResponse(message);
                    break;
                    
                case 'interrupt':
                    this.handleInterrupt();
                    break;
                    
                case 'error':
                    this.addSystemMessage(`Error: ${message.error}`);
                    break;
                    
                default:
                    console.log('Unknown message type:', message.type);
            }
        } catch (error) {
            console.error('Error parsing WebSocket message:', error);
        }
    }

    handleTranscript(message) {
        if (message.is_final) {
            // Clear interim transcript and add final
            this.clearInterimTranscript();
            this.addTranscriptLine('user', message.text, message.confidence);
            this.currentInterimTranscript = '';
        } else {
            // Update interim transcript
            this.updateInterimTranscript(message.text, message.confidence);
        }
    }

    handleAIResponse(message) {
        const responseTime = message.processingTime;
        this.responseTimeHistory.push(responseTime);
        this.messageCount++;
        
        // Update stats
        this.updateStats();
        
        // Add AI response to transcript
        this.addTranscriptLine('ai', message.text);
        
        // Handle audio if available
        if (message.hasAudio && message.audioData) {
            this.setupAudioResponse(message);
            // Auto-play the response
            setTimeout(() => this.playAudioResponse(), 100);
        } else {
            // Fallback to browser TTS
            this.playTextToSpeech(message.text);
        }
        
        // Update status
        this.speechStatus.textContent = 'AI is responding...';
        this.speechStatus.className = 'speech-indicator processing';
        
        // Reset to listening after estimated response duration
        const estimatedDuration = Math.max(message.text.length * 80, 2000);
        setTimeout(() => {
            if (this.isCallActive && !this.isSpeaking) {
                this.speechStatus.textContent = 'Listening...';
                this.speechStatus.className = 'speech-indicator listening';
            }
        }, estimatedDuration);
    }

    handleInterrupt() {
        console.log('AI response interrupted by user speech');
        this.stopAllAudio();
        this.speechStatus.textContent = 'You interrupted - continuing to listen...';
        this.speechStatus.className = 'speech-indicator listening';
    }

    setupAudioResponse(message) {
        // Clean up previous audio
        if (this.currentAudioUrl) {
            URL.revokeObjectURL(this.currentAudioUrl);
        }

        // Create audio blob
        const audioFormat = message.audioFormat || 'mp3';
        const mimeType = audioFormat === 'mp3' ? 'audio/mpeg' : `audio/${audioFormat}`;
        
        const audioBytes = atob(message.audioData);
        const audioArray = new Uint8Array(audioBytes.length);
        for (let i = 0; i < audioBytes.length; i++) {
            audioArray[i] = audioBytes.charCodeAt(i);
        }
        
        const audioBlob = new Blob([audioArray], { type: mimeType });
        this.lastAudioResponse = audioBlob;
        this.currentAudioUrl = URL.createObjectURL(audioBlob);
        
        // Setup audio element
        this.responseAudio.src = this.currentAudioUrl;
        this.responseAudio.style.display = 'block';
        this.audioStatus.textContent = 'AI audio response ready';
        this.playBtn.disabled = false;
        this.downloadBtn.disabled = false;
    }

    playAudioResponse() {
        if (this.currentAudioUrl && this.responseAudio.src) {
            this.responseAudio.play().catch(error => {
                console.error('Error playing audio:', error);
                this.audioStatus.textContent = 'Error playing audio';
            });
        }
    }

    playTextToSpeech(text) {
        if (!('speechSynthesis' in window)) return;
        
        speechSynthesis.cancel(); // Stop any current speech
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.0;
        utterance.pitch = 1.0;
        utterance.volume = 0.8;
        
        speechSynthesis.speak(utterance);
    }

    playLastResponse() {
        if (this.currentAudioUrl) {
            this.playAudioResponse();
        } else {
            this.addSystemMessage('No audio response available to replay');
        }
    }

    stopAllAudio() {
        // Stop HTML5 audio
        if (this.responseAudio && !this.responseAudio.paused) {
            this.responseAudio.pause();
            this.responseAudio.currentTime = 0;
        }

        // Stop speech synthesis
        if ('speechSynthesis' in window) {
            speechSynthesis.cancel();
        }

        this.audioStatus.textContent = 'Audio stopped';
        this.audioStatus.classList.remove('playing');
        this.stopAudioBtn.disabled = true;
    }

    downloadLastResponse() {
        if (!this.lastAudioResponse) {
            this.addSystemMessage('No audio response available for download');
            return;
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `ai-response-${timestamp}.mp3`;
        
        const downloadUrl = URL.createObjectURL(this.lastAudioResponse);
        const link = document.createElement('a');
        link.href = downloadUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        setTimeout(() => URL.revokeObjectURL(downloadUrl), 1000);
        this.addSystemMessage(`Audio downloaded as ${filename}`);
    }

    addTranscriptLine(type, text, confidence = null) {
        const line = document.createElement('div');
        line.className = `transcript-line ${type}`;
        
        const textDiv = document.createElement('div');
        textDiv.className = 'transcript-text';
        textDiv.textContent = text;
        
        const metaDiv = document.createElement('div');
        metaDiv.className = 'transcript-meta';
        
        const typeSpan = document.createElement('span');
        typeSpan.textContent = type === 'user' ? 'You' : 'AI';
        
        const timeSpan = document.createElement('span');
        timeSpan.textContent = new Date().toLocaleTimeString();
        
        metaDiv.appendChild(typeSpan);
        
        if (confidence !== null && type === 'user') {
            const confidenceBadge = document.createElement('span');
            confidenceBadge.className = `confidence-badge ${confidence < 0.7 ? (confidence < 0.5 ? 'very-low' : 'low') : ''}`;
            confidenceBadge.textContent = `${Math.round(confidence * 100)}%`;
            metaDiv.appendChild(confidenceBadge);
        }
        
        metaDiv.appendChild(timeSpan);
        
        line.appendChild(textDiv);
        line.appendChild(metaDiv);
        
        this.transcriptContainer.appendChild(line);
        this.scrollTranscriptToBottom();
        
        // Limit transcript history
        if (this.transcriptContainer.children.length > 50) {
            this.transcriptContainer.removeChild(this.transcriptContainer.firstChild);
        }
    }

    updateInterimTranscript(text, confidence) {
        // Remove existing interim transcript
        this.clearInterimTranscript();
        
        // Add new interim transcript
        const line = document.createElement('div');
        line.className = 'transcript-line interim';
        line.id = 'interim-transcript';
        
        const textDiv = document.createElement('div');
        textDiv.className = 'transcript-text';
        textDiv.textContent = text;
        
        const metaDiv = document.createElement('div');
        metaDiv.className = 'transcript-meta';
        metaDiv.innerHTML = `<span>You (speaking...)</span><span>${Math.round(confidence * 100)}%</span>`;
        
        line.appendChild(textDiv);
        line.appendChild(metaDiv);
        
        this.transcriptContainer.appendChild(line);
        this.scrollTranscriptToBottom();
    }

    clearInterimTranscript() {
        const interim = document.getElementById('interim-transcript');
        if (interim) {
            interim.remove();
        }
    }

    addSystemMessage(message) {
        this.addTranscriptLine('system', message);
    }

    scrollTranscriptToBottom() {
        this.transcriptContainer.scrollTop = this.transcriptContainer.scrollHeight;
    }

    updateStats() {
        if (this.responseTimeHistory.length > 0) {
            const last = this.responseTimeHistory[this.responseTimeHistory.length - 1];
            const avg = Math.round(this.responseTimeHistory.reduce((a, b) => a + b, 0) / this.responseTimeHistory.length);
            
            this.lastResponseTime.textContent = `${last}ms`;
            this.avgResponseTime.textContent = `${avg}ms`;
        }
        
        this.messageCountEl.textContent = this.messageCount.toString();
    }

    updateCallStatus(status, text) {
        this.callStatus.className = `call-status ${status}`;
        this.callStatus.textContent = text;
    }

    endCall() {
        this.isCallActive = false;
        this.isRecording = false;
        
        // Stop all audio processing
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
            this.mediaRecorder.stop();
        }
        
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
        }
        
        if (this.audioContext) {
            this.audioContext.close();
        }
        
        if (this.silenceTimeout) {
            clearTimeout(this.silenceTimeout);
        }
        
        // Close WebSocket
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
        
        // Stop any playing audio
        this.stopAllAudio();
        
        // Reset UI
        this.updateCallStatus('disconnected', 'Call Ended');
        this.startCallBtn.disabled = false;
        this.endCallBtn.disabled = true;
        this.speechStatus.textContent = 'Call ended';
        this.speechStatus.className = 'speech-indicator idle';
        this.inputVolumeBar.style.height = '0%';
        
        // Add summary
        if (this.callStartTime) {
            const duration = Math.floor((Date.now() - this.callStartTime) / 1000);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            this.addSystemMessage(`Call ended - Duration: ${minutes}:${seconds.toString().padStart(2, '0')}, Messages: ${this.messageCount}`);
        }
        
        this.callStartTime = null;
    }
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', () => {
    new LiveVoiceCall();
});
</script>
</body>
</html>