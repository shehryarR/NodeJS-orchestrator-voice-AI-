<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Voice Chat with LLM</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    background: white;
    border-radius: 15px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.1);
    overflow: hidden;
}

h1 {
    background: linear-gradient(45deg, #667eea, #764ba2);
    color: white;
    text-align: center;
    padding: 20px;
    margin: 0;
    font-size: 1.8rem;
}

.status {
    text-align: center;
    padding: 15px;
    font-weight: bold;
    font-size: 1.1rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.status.connected {
    background: #4CAF50;
    color: white;
}

.status.disconnected {
    background: #f44336;
    color: white;
}

.controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
    padding: 20px;
    background: #f5f5f5;
}

.btn {
    padding: 12px 24px;
    border: none;
    border-radius: 25px;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    min-width: 120px;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

#connectBtn {
    background: #2196F3;
    color: white;
}

#recordBtn {
    background: #FF5722;
    color: white;
}

#recordBtn.recording {
    background: #f44336;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

#playBtn {
    background: #4CAF50;
    color: white;
}

#stopAudioBtn {
    background: #ff9800;
    color: white;
}

#uploadBtn {
    background: #9C27B0;
    color: white;
}

#downloadBtn {
    background: #607D8B;
    color: white;
}

.file-upload-section {
    padding: 15px 20px;
    background: #f9f9f9;
    border-top: 1px solid #ddd;
    border-bottom: 1px solid #ddd;
}

.file-upload-section h2 {
    color: #333;
    margin-bottom: 15px;
    font-size: 1.2rem;
    text-align: center;
}

.file-upload-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
}

.file-input-wrapper {
    position: relative;
    display: inline-block;
    cursor: pointer;
    background: #673AB7;
    color: white;
    padding: 12px 24px;
    border-radius: 25px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    transition: all 0.3s ease;
}

.file-input-wrapper:hover {
    background: #5E35B1;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

#audioFileInput {
    position: absolute;
    left: -9999px;
}

.file-info {
    text-align: center;
    font-size: 0.9rem;
    color: #666;
    padding: 10px;
    background: white;
    border-radius: 8px;
    border: 1px solid #ddd;
    min-width: 250px;
}

.file-selected {
    background: #e8f5e8 !important;
    border-color: #4CAF50 !important;
    color: #2e7d32;
}

.supported-formats {
    font-size: 0.8rem;
    color: #666;
    text-align: center;
    margin-top: 5px;
}

.audio-controls {
    padding: 15px 20px;
    background: #e8f5e8;
    border-top: 1px solid #ddd;
    border-bottom: 1px solid #ddd;
    text-align: center;
}

.audio-controls h2 {
    color: #2e7d32;
    margin-bottom: 15px;
    font-size: 1.2rem;
}

.audio-player-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
}

.audio-controls-row {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-top: 10px;
}

.audio-status {
    font-size: 0.9rem;
    color: #666;
    padding: 8px 16px;
    background: white;
    border-radius: 20px;
    border: 1px solid #ddd;
}

.audio-status.playing {
    background: #c8e6c9;
    border-color: #4CAF50;
    color: #2e7d32;
}

.download-info {
    font-size: 0.8rem;
    color: #666;
    text-align: center;
    margin-top: 5px;
    font-style: italic;
}

.transcript {
    padding: 20px;
    border-top: 1px solid #eee;
}

.transcript h2 {
    color: #333;
    margin-bottom: 15px;
    font-size: 1.3rem;
}

.conversation {
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid #ddd;
    border-radius: 10px;
    padding: 15px;
    background: #fafafa;
}

.message {
    margin: 10px 0;
    padding: 12px;
    border-radius: 10px;
    position: relative;
}

.user-message {
    background: #e3f2fd;
    border-left: 4px solid #2196F3;
}

.ai-message {
    background: #f3e5f5;
    border-left: 4px solid #9c27b0;
}

.system-message {
    background: #fff3e0;
    border-left: 4px solid #ff9800;
    font-style: italic;
}

.timestamp {
    font-size: 0.8rem;
    color: #666;
    margin-top: 5px;
}

.latency {
    font-size: 0.8rem;
    color: #009688;
    font-weight: bold;
    margin-top: 5px;
}

.audio-indicator {
    font-size: 0.8rem;
    color: #4CAF50;
    font-weight: bold;
    margin-top: 5px;
}

.latency-stats {
    padding: 15px 20px;
    background: #e8f5e8;
    border-top: 1px solid #ddd;
    text-align: center;
}

.latency-stats h3 {
    color: #2e7d32;
    margin-bottom: 10px;
    font-size: 1.1rem;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 15px;
    margin-top: 10px;
}

.stat-item {
    background: white;
    padding: 10px;
    border-radius: 8px;
    border: 1px solid #c8e6c9;
}

.stat-label {
    font-size: 0.8rem;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.stat-value {
    font-size: 1.2rem;
    font-weight: bold;
    color: #2e7d32;
    margin-top: 2px;
}

.audio-visualization {
    padding: 20px;
    text-align: center;
    border-top: 1px solid #eee;
}

.audio-visualization h2 {
    color: #333;
    margin-bottom: 15px;
    font-size: 1.3rem;
}

#visualizer {
    border: 2px solid #ddd;
    border-radius: 10px;
    background: #f0f0f0;
    width: 100%;
    max-width: 400px;
    height: 100px;
}

/* Responsive design */
@media (max-width: 600px) {
    .controls {
        flex-direction: column;
        align-items: center;
    }
    
    .btn {
        width: 200px;
    }
    
    .file-upload-container {
        width: 100%;
    }
    
    .file-info {
        min-width: auto;
        width: 100%;
    }
    
    .audio-controls-row {
        flex-direction: column;
        align-items: center;
    }
}
</style>
</head>
<body>
<div class="container">
<h1>Voice Chat with LLM</h1>
<div class="status" id="status">Disconnected</div>
<div class="controls">
<button id="connectBtn" class="btn">Connect</button>
<button id="recordBtn" class="btn" disabled>Start Recording</button>
<button id="playBtn" class="btn" disabled>Play Response</button>
<button id="stopAudioBtn" class="btn" disabled>Stop Audio</button>
</div>

<div class="file-upload-section">
<h2>Upload Audio File</h2>
<div class="file-upload-container">
<label for="audioFileInput" class="file-input-wrapper">
Choose Audio File
</label>
<input type="file" id="audioFileInput" accept="audio/*" />
<div class="file-info" id="fileInfo">No file selected</div>
<button id="uploadBtn" class="btn" disabled>Upload & Send</button>
<div class="supported-formats">
Supported: MP3, WAV, M4A, WEBM, OGG, FLAC
</div>
</div>
</div>

<div class="audio-controls">
<h2>AI Audio Response</h2>
<div class="audio-player-section">
<div class="audio-status" id="audioStatus">No audio available</div>
<audio id="responseAudio" controls style="display: none; width: 100%; max-width: 400px;"></audio>
<div class="audio-controls-row">
<button id="downloadBtn" class="btn" disabled>Download WebM</button>
</div>
<div class="download-info">Audio will be converted to WebM format for download</div>
</div>
</div>

<div class="latency-stats">
<h3>Performance Stats</h3>
<div class="stats-grid">
<div class="stat-item">
<div class="stat-label">Last Response</div>
<div class="stat-value" id="lastLatency">--</div>
</div>
<div class="stat-item">
<div class="stat-label">Average</div>
<div class="stat-value" id="avgLatency">--</div>
</div>
<div class="stat-item">
<div class="stat-label">Best</div>
<div class="stat-value" id="minLatency">--</div>
</div>
<div class="stat-item">
<div class="stat-label">Worst</div>
<div class="stat-value" id="maxLatency">--</div>
</div>
</div>
</div>
<div class="transcript">
<h2>Conversation</h2>
<div id="conversation" class="conversation"></div>
</div>
<div class="audio-visualization">
<h2>Audio Input</h2>
<canvas id="visualizer" width="400" height="100"></canvas>
</div>
</div>

<script>
class VoiceChatClient {
    constructor() {
        this.ws = null;
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.isRecording = false;
        this.callSid = 'web-client-' + Math.random().toString(36).substring(2, 10);
        this.audioContext = null;
        this.analyser = null;
        this.animationFrame = null;
        this.lastAudioData = null;
        this.isSpeaking = false;
        this.currentUtterance = null;
        this.selectedFile = null;
        this.currentAudioUrl = null;
        this.isPlayingAudio = false;
        this.currentAudioBlob = null; // Store the original audio blob for download
        
        // Performance tracking
        this.requestStartTime = null;
        this.latencyHistory = [];
        
        this.initializeElements();
        this.setupEventListeners();
    }

    initializeElements() {
        this.statusElement = document.getElementById('status');
        this.connectBtn = document.getElementById('connectBtn');
        this.recordBtn = document.getElementById('recordBtn');
        this.playBtn = document.getElementById('playBtn');
        this.stopAudioBtn = document.getElementById('stopAudioBtn');
        this.uploadBtn = document.getElementById('uploadBtn');
        this.downloadBtn = document.getElementById('downloadBtn');
        this.audioFileInput = document.getElementById('audioFileInput');
        this.fileInfo = document.getElementById('fileInfo');
        this.conversationElement = document.getElementById('conversation');
        this.visualizerCanvas = document.getElementById('visualizer');
        this.visualizerCtx = this.visualizerCanvas.getContext('2d');
        this.responseAudio = document.getElementById('responseAudio');
        this.audioStatus = document.getElementById('audioStatus');
        
        // Performance stats elements
        this.lastLatencyElement = document.getElementById('lastLatency');
        this.avgLatencyElement = document.getElementById('avgLatency');
        this.minLatencyElement = document.getElementById('minLatency');
        this.maxLatencyElement = document.getElementById('maxLatency');
    }

    setupEventListeners() {
        this.connectBtn.addEventListener('click', () => {
            if (this.ws?.readyState === WebSocket.OPEN) {
                this.disconnect();
            } else {
                this.connect();
            }
        });

        this.recordBtn.addEventListener('click', () => {
            if (this.isRecording) {
                this.stopRecording();
            } else {
                this.startRecording();
            }
        });

        this.playBtn.addEventListener('click', () => {
            this.playLastResponse();
        });

        this.stopAudioBtn.addEventListener('click', () => {
            this.stopAllAudio();
        });

        this.uploadBtn.addEventListener('click', () => {
            this.uploadAudioFile();
        });

        this.downloadBtn.addEventListener('click', () => {
            this.downloadAudioResponse();
        });

        this.audioFileInput.addEventListener('change', (event) => {
            this.handleFileSelection(event);
        });

        this.responseAudio.addEventListener('play', () => {
            this.isPlayingAudio = true;
            this.audioStatus.textContent = 'Playing AI response...';
            this.audioStatus.classList.add('playing');
            this.stopAudioBtn.disabled = false;
        });

        this.responseAudio.addEventListener('pause', () => {
            this.isPlayingAudio = false;
            this.audioStatus.textContent = 'Audio paused';
            this.audioStatus.classList.remove('playing');
            this.stopAudioBtn.disabled = true;
        });

        this.responseAudio.addEventListener('ended', () => {
            this.isPlayingAudio = false;
            this.audioStatus.textContent = 'Audio ready to play';
            this.audioStatus.classList.remove('playing');
            this.stopAudioBtn.disabled = true;
        });
    }

    handleFileSelection(event) {
        const file = event.target.files[0];
        if (file) {
            this.selectedFile = file;
            const fileSize = (file.size / 1024 / 1024).toFixed(2);
            const fileName = file.name.length > 30 ? file.name.substring(0, 27) + '...' : file.name;
            
            this.fileInfo.textContent = `Selected: ${fileName} (${fileSize} MB)`;
            this.fileInfo.classList.add('file-selected');
            
            // Enable upload button if connected
            this.uploadBtn.disabled = !(this.ws?.readyState === WebSocket.OPEN);
            
            this.addMessage('System', `File selected: ${file.name} (${fileSize} MB)`);
        } else {
            this.selectedFile = null;
            this.fileInfo.textContent = 'No file selected';
            this.fileInfo.classList.remove('file-selected');
            this.uploadBtn.disabled = true;
        }
    }

    uploadAudioFile() {
        if (!this.selectedFile || this.ws?.readyState !== WebSocket.OPEN) {
            this.addMessage('System', 'Please select a file and ensure connection');
            return;
        }

        const maxSize = 25 * 1024 * 1024; // 25MB limit
        if (this.selectedFile.size > maxSize) {
            this.addMessage('System', 'File too large. Maximum size is 25MB');
            return;
        }

        this.uploadBtn.disabled = true;
        this.uploadBtn.textContent = 'Uploading...';
        this.addMessage('You', `Uploading: ${this.selectedFile.name}`);

        const reader = new FileReader();
        reader.onload = () => {
            const base64Audio = reader.result.split(',')[1];
            this.sendAudioData(base64Audio, 'file');
        };
        
        reader.onerror = () => {
            this.addMessage('System', 'Error reading file');
            this.uploadBtn.disabled = false;
            this.uploadBtn.textContent = 'Upload & Send';
        };
        
        reader.readAsDataURL(this.selectedFile);
    }

    connect() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}?callSid=${this.callSid}`;
        
        this.ws = new WebSocket(wsUrl);
        
        this.ws.onopen = () => {
            this.updateStatus('connected');
            this.connectBtn.textContent = 'Disconnect';
            this.recordBtn.disabled = false;
            this.uploadBtn.disabled = !this.selectedFile;
            this.addMessage('System', 'Connected to server');
            this.latencyHistory = [];
            this.updateLatencyStats();
        };
        
        this.ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                if (message.type === 'audio') {
                    const latency = this.calculateLatency();
                    this.handleAudioResponse(message.audio, latency);
                } else if (message.type === 'error') {
                    this.addMessage('System', `Error: ${message.error}`);
                }
            } catch (error) {
                console.error('Error parsing message:', error);
                this.addMessage('System', 'Error parsing server response');
            }
        };
        
        this.ws.onclose = () => {
            this.updateStatus('disconnected');
            this.connectBtn.textContent = 'Connect';
            this.recordBtn.disabled = true;
            this.uploadBtn.disabled = true;
            this.addMessage('System', 'Disconnected from server');
        };
        
        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.addMessage('System', 'Connection error');
        };
    }

    disconnect() {
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
        this.stopAllAudio();
    }

    updateStatus(status) {
        this.statusElement.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        this.statusElement.className = `status ${status}`;
    }

    async startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                audio: { 
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                } 
            });
            
            this.mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'audio/webm;codecs=opus'
            });
            this.audioChunks = [];
            
            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.audioChunks.push(event.data);
                }
            };
            
            this.mediaRecorder.onstop = () => {
                const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                this.sendAudio(audioBlob);
                // Stop all tracks to free up microphone
                stream.getTracks().forEach(track => track.stop());
            };
            
            this.mediaRecorder.start();
            this.isRecording = true;
            this.recordBtn.textContent = 'Stop Recording';
            this.recordBtn.classList.add('recording');
            
            this.setupAudioVisualization(stream);
            this.addMessage('You', 'Recording...');
        } catch (error) {
            console.error('Error starting recording:', error);
            this.addMessage('System', 'Microphone access denied or unavailable');
        }
    }

    stopRecording() {
        if (this.mediaRecorder && this.isRecording) {
            this.mediaRecorder.stop();
            this.isRecording = false;
            this.recordBtn.textContent = 'Start Recording';
            this.recordBtn.classList.remove('recording');
            
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
                this.animationFrame = null;
            }
            
            // Clean up audio context
            if (this.audioContext) {
                this.audioContext.close();
                this.audioContext = null;
            }
            
            this.addMessage('You', 'Processing audio...');
        }
    }

    sendAudio(audioBlob) {
        if (this.ws?.readyState === WebSocket.OPEN) {
            const reader = new FileReader();
            reader.onload = () => {
                const base64Audio = reader.result.split(',')[1];
                this.sendAudioData(base64Audio, 'live');
                this.addMessage('You', 'Audio sent to AI');
            };
            reader.readAsDataURL(audioBlob);
        } else {
            this.addMessage('System', 'Not connected to server');
        }
    }

    sendAudioData(base64Audio, source) {
        this.requestStartTime = performance.now();
        
        this.ws.send(JSON.stringify({
            type: 'audio',
            audio: base64Audio,
            source: source
        }));

        if (source === 'file') {
            this.uploadBtn.textContent = 'Upload & Send';
            this.uploadBtn.disabled = false;
            this.addMessage('You', 'File sent to AI');
        }
    }

    handleAudioResponse(audioData, latency) {
        this.lastAudioData = audioData;
        
        if (latency !== null) {
            this.latencyHistory.push(latency);
            this.updateLatencyStats();
        }
        
        // Extract text from audio response
        let responseText = 'AI response received';
        let hasAudio = false;
        
        if (audioData && audioData.text) {
            responseText = audioData.text;
        }

        // Check if we have audio data from EvenLabs
        if (audioData && audioData.audioData) {
            hasAudio = true;
            this.setupAudioResponse(audioData);
        }
        
        this.addMessage('AI', responseText, latency, hasAudio);
        
        // Auto-play audio if available and not manually disabled
        if (hasAudio && !this.isPlayingAudio) {
            setTimeout(() => {
                this.playAudioResponse();
            }, 100); // Small delay to ensure audio is loaded
        } else if (!hasAudio) {
            // Fallback to text-to-speech if no audio from server
            this.playTextToSpeech(responseText);
        }
        
        this.playBtn.disabled = false;
    }

    setupAudioResponse(audioData) {
        // Clean up previous audio URL
        if (this.currentAudioUrl) {
            URL.revokeObjectURL(this.currentAudioUrl);
        }

        // Create audio blob from base64 data
        const audioFormat = audioData.audioFormat || 'mp3';
        const mimeType = audioFormat === 'mp3' ? 'audio/mpeg' : `audio/${audioFormat}`;
        
        const audioBytes = atob(audioData.audioData);
        const audioArray = new Uint8Array(audioBytes.length);
        for (let i = 0; i < audioBytes.length; i++) {
            audioArray[i] = audioBytes.charCodeAt(i);
        }
        
        const audioBlob = new Blob([audioArray], { type: mimeType });
        this.currentAudioBlob = audioBlob; // Store for download
        this.currentAudioUrl = URL.createObjectURL(audioBlob);
        
        // Set up audio element
        this.responseAudio.src = this.currentAudioUrl;
        this.responseAudio.style.display = 'block';
        this.audioStatus.textContent = 'AI audio response ready';
        this.downloadBtn.disabled = false; // Enable download button
        
        console.log(`Audio response loaded: ${audioFormat}, ${audioArray.length} bytes`);
    }

    async downloadAudioResponse() {
        if (!this.currentAudioBlob) {
            this.addMessage('System', 'No audio response available for download');
            return;
        }

        try {
            this.downloadBtn.disabled = true;
            this.downloadBtn.textContent = 'Converting...';
            
            // Convert audio to WebM format using Web Audio API
            const webmBlob = await this.convertToWebM(this.currentAudioBlob);
            
            // Create download link
            const downloadUrl = URL.createObjectURL(webmBlob);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `ai-response-${timestamp}.webm`;
            
            // Create temporary link and trigger download
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up
            setTimeout(() => {
                URL.revokeObjectURL(downloadUrl);
            }, 1000);
            
            this.addMessage('System', `Audio downloaded as ${filename}`);
            
        } catch (error) {
            console.error('Error downloading audio:', error);
            this.addMessage('System', 'Error converting audio for download');
        } finally {
            this.downloadBtn.disabled = false;
            this.downloadBtn.textContent = 'Download WebM';
        }
    }

    async convertToWebM(audioBlob) {
        // If the audio is already in WebM format, return as is
        if (audioBlob.type.includes('webm')) {
            return audioBlob;
        }

        // For other formats, we'll use a simple approach
        // In a real implementation, you might want to use FFmpeg.js or similar
        // For now, we'll try to re-encode using MediaRecorder if possible
        
        try {
            // Create an audio element to decode the audio
            const audio = new Audio();
            const audioUrl = URL.createObjectURL(audioBlob);
            audio.src = audioUrl;
            
            // Wait for audio to load
            await new Promise((resolve, reject) => {
                audio.addEventListener('loadeddata', resolve);
                audio.addEventListener('error', reject);
            });

            // Create audio context for processing
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaElementSource(audio);
            
            // Create a destination for recording
            const dest = audioContext.createMediaStreamDestination();
            source.connect(dest);
            
            // Record to WebM
            const mediaRecorder = new MediaRecorder(dest.stream, {
                mimeType: 'audio/webm;codecs=opus'
            });
            
            const chunks = [];
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    chunks.push(event.data);
                }
            };
            
            return new Promise((resolve, reject) => {
                mediaRecorder.onstop = () => {
                    const webmBlob = new Blob(chunks, { type: 'audio/webm' });
                    audioContext.close();
                    URL.revokeObjectURL(audioUrl);
                    resolve(webmBlob);
                };
                
                mediaRecorder.onerror = reject;
                
                mediaRecorder.start();
                audio.play();
                
                // Stop recording when audio ends
                audio.addEventListener('ended', () => {
                    mediaRecorder.stop();
                });
            });
            
        } catch (error) {
            // If conversion fails, try to return the original blob with WebM mime type
            // This is a fallback that may not always work perfectly
            console.warn('Audio conversion failed, using original blob:', error);
            return new Blob([audioBlob], { type: 'audio/webm' });
        }
    }

    playAudioResponse() {
        if (this.currentAudioUrl && this.responseAudio.src) {
            this.responseAudio.play().catch(error => {
                console.error('Error playing audio:', error);
                this.addMessage('System', 'Error playing audio response');
                this.audioStatus.textContent = 'Error playing audio';
            });
        }
    }

    playTextToSpeech(text) {
        if (!('speechSynthesis' in window)) {
            return;
        }

        if (this.currentUtterance) {
            speechSynthesis.cancel();
        }
        
        this.isSpeaking = true;
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.1;
        utterance.pitch = 1.0;
        utterance.volume = 0.9;
        
        utterance.onend = () => {
            this.isSpeaking = false;
            this.currentUtterance = null;
        };
        
        utterance.onerror = () => {
            this.isSpeaking = false;
            this.currentUtterance = null;
        };
        
        this.currentUtterance = utterance;
        speechSynthesis.speak(utterance);
    }

    calculateLatency() {
        if (this.requestStartTime) {
            const latency = Math.round(performance.now() - this.requestStartTime);
            this.requestStartTime = null;
            return latency;
        }
        return null;
    }

    updateLatencyStats() {
        if (this.latencyHistory.length === 0) {
            ['lastLatency', 'avgLatency', 'minLatency', 'maxLatency'].forEach(id => {
                document.getElementById(id).textContent = '--';
            });
            return;
        }

        const last = this.latencyHistory[this.latencyHistory.length - 1];
        const avg = Math.round(this.latencyHistory.reduce((a, b) => a + b, 0) / this.latencyHistory.length);
        const min = Math.min(...this.latencyHistory);
        const max = Math.max(...this.latencyHistory);

        this.lastLatencyElement.textContent = `${last}ms`;
        this.avgLatencyElement.textContent = `${avg}ms`;
        this.minLatencyElement.textContent = `${min}ms`;
        this.maxLatencyElement.textContent = `${max}ms`;
    }

    playLastResponse() {
        if (this.currentAudioUrl) {
            this.playAudioResponse();
            this.addMessage('System', 'Replaying last audio response...');
        } else if (this.lastAudioData && this.lastAudioData.text) {
            this.playTextToSpeech(this.lastAudioData.text);
            this.addMessage('System', 'Playing last response with TTS...');
        } else {
            this.addMessage('System', 'No response to replay');
        }
    }

    stopAllAudio() {
        // Stop HTML5 audio
        if (this.responseAudio && !this.responseAudio.paused) {
            this.responseAudio.pause();
            this.responseAudio.currentTime = 0;
        }

        // Stop speech synthesis
        if (this.isSpeaking && 'speechSynthesis' in window) {
            speechSynthesis.cancel();
            this.isSpeaking = false;
            this.currentUtterance = null;
        }

        this.audioStatus.textContent = 'Audio stopped';
        this.audioStatus.classList.remove('playing');
        this.stopAudioBtn.disabled = true;
    }

    addMessage(sender, text, latency = null, hasAudio = false) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${this.getMessageClass(sender)}`;
        
        const messageText = document.createElement('div');
        messageText.textContent = text;
        
        const timestamp = document.createElement('div');
        timestamp.className = 'timestamp';
        timestamp.textContent = new Date().toLocaleTimeString();
        
        messageDiv.appendChild(messageText);
        messageDiv.appendChild(timestamp);
        
        if (latency !== null) {
            const latencyDiv = document.createElement('div');
            latencyDiv.className = 'latency';
            latencyDiv.textContent = `${latency}ms`;
            messageDiv.appendChild(latencyDiv);
        }

        if (hasAudio) {
            const audioDiv = document.createElement('div');
            audioDiv.className = 'audio-indicator';
            audioDiv.textContent = '🔊 Audio response';
            messageDiv.appendChild(audioDiv);
        }
        
        this.conversationElement.appendChild(messageDiv);
        this.conversationElement.scrollTop = this.conversationElement.scrollHeight;
        
        // Limit conversation history to prevent memory issues
        if (this.conversationElement.children.length > 50) {
            this.conversationElement.removeChild(this.conversationElement.firstChild);
        }
    }

    getMessageClass(sender) {
        switch (sender) {
            case 'You': return 'user-message';
            case 'System': return 'system-message';
            default: return 'ai-message';
        }
    }

    setupAudioVisualization(stream) {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.analyser = this.audioContext.createAnalyser();
        const source = this.audioContext.createMediaStreamSource(stream);
        source.connect(this.analyser);
        
        this.analyser.fftSize = 128;
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const draw = () => {
            if (!this.isRecording) return;
            
            this.animationFrame = requestAnimationFrame(draw);
            this.analyser.getByteFrequencyData(dataArray);
            
            this.visualizerCtx.fillStyle = '#f0f0f0';
            this.visualizerCtx.fillRect(0, 0, this.visualizerCanvas.width, this.visualizerCanvas.height);
            
            const barWidth = (this.visualizerCanvas.width / bufferLength) * 2;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (dataArray[i] / 255) * this.visualizerCanvas.height * 0.8;
                
                this.visualizerCtx.fillStyle = `hsl(${(barHeight / this.visualizerCanvas.height) * 120}, 70%, 50%)`;
                this.visualizerCtx.fillRect(x, this.visualizerCanvas.height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
        };
        
        draw();
    }
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', () => {
    new VoiceChatClient();
});
</script>
</body>
</html>