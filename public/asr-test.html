<!DOCTYPE html>
<html>
<head>
  <title>ASR Test Only</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    #transcript { margin-top: 20px; padding: 10px; background: #f0f0f0; min-height: 50px; }
    .final { color: black; font-weight: bold; }
    .interim { color: #666; font-style: italic; }
  </style>
</head>
<body>
  <h2>ðŸŽ¤ ASR Test (Deepgram Only)</h2>
  <button id="start">Start Mic</button>
  <button id="stop" disabled>Stop</button>
  <div id="status">Status: Not Connected</div>
  <div id="transcript"></div>

  <script>
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const statusDiv = document.getElementById('status');
    const transcriptDiv = document.getElementById('transcript');

    let ws;
    let audioContext;
    let mediaStream;
    let processor;

    startBtn.onclick = async () => {
      try {
        ws = new WebSocket(`ws://${window.location.host}`);

        ws.onopen = () => {
          statusDiv.textContent = 'Status: Connected to ASR';
          startBtn.disabled = true;
          stopBtn.disabled = false;
        };

        ws.onmessage = (event) => {
          const msg = JSON.parse(event.data);
          if (msg.type === 'asr_status') {
            statusDiv.textContent = `Status: ${msg.status}`;
          } else if (msg.type === 'transcript') {
            const line = document.createElement('div');
            line.textContent = msg.text;
            line.className = msg.is_final ? 'final' : 'interim';
            transcriptDiv.appendChild(line);
            transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
          } else if (msg.type === 'asr_error') {
            statusDiv.textContent = `Error: ${msg.error}`;
          }
        };

        ws.onclose = () => {
          statusDiv.textContent = 'Status: Disconnected';
          startBtn.disabled = false;
          stopBtn.disabled = true;
        };

        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new AudioContext({ sampleRate: 48000 });

        // ðŸ‘‡ REQUIRED: Resume AudioContext to comply with autoplay policy
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        const source = audioContext.createMediaStreamSource(mediaStream);
        processor = audioContext.createScriptProcessor(4096, 1, 1);

        processor.onaudioprocess = (e) => {
          const inputData = e.inputBuffer.getChannelData(0); // Float32Array

          // âœ… SEND RAW FLOAT32 BINARY DATA
          const rawBuffer = inputData.buffer.slice(
            inputData.byteOffset,
            inputData.byteOffset + inputData.byteLength
          );

          if (ws.readyState === WebSocket.OPEN) {
            ws.send(rawBuffer);
          }
        };

        source.connect(processor);
        processor.connect(audioContext.destination);

      } catch (err) {
        console.error('Error:', err);
        statusDiv.textContent = `Error: ${err.message}`;
      }
    };

    stopBtn.onclick = () => {
      if (processor) {
        processor.disconnect();
        processor = null;
      }
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
      }
      if (ws) {
        ws.close();
        ws = null;
      }
      startBtn.disabled = false;
      stopBtn.disabled = true;
      statusDiv.textContent = 'Status: Stopped';
    };
  </script>
</body>
</html>


